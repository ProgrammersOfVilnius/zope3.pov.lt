#
# buildbot master configuration for Zope KGS
#

import re, time

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

# The 'projectName' string will be used to describe the project that this
# buildbot is working on. For example, it is used as the title of the
# waterfall HTML page. The 'projectURL' string will be used to provide a link
# from buildbot HTML pages to your project's home page.
c['projectName'] = "Zope 3.4 Known Good Set"
c['projectURL'] = "http://download.zope.org/zope3.4/intro.html"

# The 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.
c['buildbotURL'] = "https://zope3.pov.lt/buildbot/"

# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)
c['slavePortnum'] = 9986

# The 'bots' list defines the set of allowable buildslaves. Each element is a
# tuple of bot-name and bot-password.
c['bots'] = [("muskatas", "secret"),
             ("sink", "secret")]

# The 'sources' list tells the buildmaster how it should find out about
# source code changes.
c['sources'] = []

# The 'schedulers' list tells the buildmaster when to build what.
from buildbot.scheduler import Nightly
c['schedulers'] = [
    Nightly(name="nightly",
            hour=4, minute=0, # every night at 4 AM
            builderNames=[
                "py2.4-32bit-linux",
                "py2.4-64bit-linux",
                "py2.5-32bit-linux",
                "py2.5-64bit-linux",
            ]),
]

# The 'builders' list defines the Builders. Each one is configured with a
# dictionary, using the following keys:
#  name (required): the name used to describe this bilder
#  slavename (required): which slave to use, must appear in c['bots']
#  builddir (required): which subdirectory to run the builder in
#  factory (required): a BuildFactory to define how the build is run
#  periodicBuildTime (optional): if set, force a build every N seconds
from buildbot.process import factory, step
from twisted.internet import reactor

class SVN(step.SVN):

    show_revno = False # the LastChange step does it better

    def createSummary(self, log):
        log_text = log.getText()
        if self.show_revno:
            revno = self.extractRevno(log_text)
            if revno:
                self.descriptionDone = self.descriptionDone + ['r%s' % revno]

    def extractRevno(self, log_text):
        try:
            start_idx = log_text.rindex('At revision')
            end_idx = log_text.find('\n', start_idx)
        except ValueError:
            return None
        line = log_text[start_idx:end_idx]
        try:
            return re.findall('([0-9]+)', line)[0]
        except IndexError:
            return None


class LastChange(step.ShellCommand):

    command = ['svn', 'log', '--limit', '1']
    name = 'svn-last-change'
    description = ['svn log --limit 1']
    descriptionDone = ['last change']

    # xxx hardcoded
    url_template = 'http://zope3.pov.lt/trac/log/zope.release?rev=%s'

    def createSummary(self, log):
        log_text = log.getText()
        revno = self.extractRevno(log_text)
        if revno:
            text = self.formatRevno(revno)
            self.descriptionDone = self.descriptionDone + [text]

    def formatRevno(self, revno):
        text = 'r%s' % revno
        if self.url_template:
            url = self.url_template % revno
            text = '<a class="revlink" href="%s">%s</a>' % (url, text)
        return text

    def extractRevno(self, log_text):
        for line in log_text.splitlines():
            if line.startswith('r'):
                return line.split()[0][1:]
        return None


class Test(step.Test):

    started = None
    stopped = None

    tick_every = 10 # seconds

    def start(self):
        step.Test.start(self)
        self.started = time.time()
        reactor.callLater(self.tick_every, self.tick)

    def finished(self, results):
        if not self.stopped:
            self.stopped = time.time()
        step.Test.finished(self, results)
 
    def tick(self):
        if not self.stopped:
            self.step_status.setText(self.describe(False))
            reactor.callLater(self.tick_every, self.tick)

    def describe(self, done=False):
        description = step.Test.describe(self, done=done)
        if not done and self.started:
            running = time.time() - self.started
            description = description + [self.formatTime(running)]
        return description

    def createSummary(self, log):
        if not self.started:
            # just in case something async happens
            self.started = time.time()
        self.stopped = time.time()
        log_text = log.getText()
        totals = self.extractTotals(log_text)
        if totals:
            self.descriptionDone = self.descriptionDone + [totals]
        # the test runner lies about the time
        ## time_info = self.extractTime(log_text)
        time_info = self.formatTime(self.stopped - self.started)
        if time_info:
            self.descriptionDone = self.descriptionDone + [time_info]
        summary = self.extractSummary(log_text)
        if summary:
            self.addCompleteLog('summary', summary)

    def formatTime(self, seconds):
        return '%dm%02ds' % divmod(seconds, 60)

    def extractTotalsLine(self, log_text):
        try:
            start_idx = log_text.rindex('Total:')
            end_idx = log_text.find('\n', start_idx)
        except ValueError:
            return None
        return log_text[start_idx:end_idx]

    def extractTotals(self, log_text):
        totals_line = self.extractTotalsLine(log_text)
        if not totals_line:
            return None
        # Total: X tests, X failures, X errors in X minutes X.Y seconds.
        ntests, nfail, nerr = re.findall('([0-9.]+)', totals_line)[:3]
        return '%s/%s/%s' % (ntests, nfail, nerr)

    def extractTime(self, log_text):
        totals_line = self.extractTotalsLine(log_text)
        if not totals_line:
            return None
        # Total: X tests, X failures, X errors in [X minutes] X.Y seconds.
        time = totals_line.split(' in ')[-1]
        time = time.replace(' minutes ', 'm')
        time = time.replace(' seconds.', 's')
        time = re.sub('[.][0-9]+s', 's', time)
        return time

    def extractSummary(self, log_text):
        summary_idx = len(log_text)
        for interesting in ['Tests with errors:',
                            'Tests with failures:',
                            'Total:']:
            try:
                summary_idx = min(summary_idx,
                                  log_text.rindex('Tests with errors:'))
            except ValueError:
                pass
        return log_text[summary_idx:]


def builder(name, slavename):
    pythonver = name.split('-')[0].lstrip('python')
    python = "python%s" % pythonver
    builddir = name
    f = factory.BuildFactory()
    f.addStep(SVN,
              svnurl="svn://svn.zope.org/repos/main/zope.release/branches/3.4",
              mode="update")
    f.addStep(LastChange)
    f.addStep(step.ShellCommand,
              command=[python, "/usr/local/bin/virtualenv.py", "--no-site-packages", "sandbox"],
              name="virtualenv",
              description="virtualenv")
    f.addStep(step.ShellCommand,
              command=["sandbox/bin/python", "bootstrap.py"],
              name="bootstrap",
              description="bootstrap")
    f.addStep(step.ShellCommand,
              command=["bin/buildout"],
              name="buildout",
              description="buildout")
    f.addStep(step.ShellCommand,
              command=["bin/generate-buildout"],
              name="generate-buildout",
              description="generate-buildout")
    f.addStep(step.ShellCommand,
              workdir="build/test",
              command=["../bin/buildout"],
              name="buildout-test-env",
              description="cd test && buildout")
    f.addStep(Test,
              workdir="build/test",
              command=["bin/test", "-v", "-1", "--exit-with-status"])
    return dict(name=name,
                slavename=slavename,
                builddir=builddir,
                factory=f)

c['builders'] = [
    builder("py2.4-32bit-linux", 'sink'),
    builder("py2.4-64bit-linux", 'muskatas'),
    builder("py2.5-32bit-linux", 'sink'),
    builder("py2.5-64bit-linux", 'muskatas'),
]

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.
from buildbot.status.html import Waterfall
from buildbot.status.mail import MailNotifier
c['status'] = [
    Waterfall(http_port=8014, css="/var/lib/buildbot/buildbot.css"),
# No point in having it enabled while all the tests are failing
##  MailNotifier(mode="failing", fromaddr="buildbot@pov.lt",
##               extraRecipients=["marius@pov.lt"],
##               sendToInterestedUsers=False),
]

# vim:set ft=python:
